package classes.day5;
/*
인스턴스화에서 선언부와 생성부의 타입이 다른 경우
1) 부모에는 없는데 자손에는 있는 메소드 n() 추가
2) 테스트 시나리오
- Parent p = new Parent(); : 기본
- Parent p = new Child(); : 부모타입과 생성자 타입이 다른 경우 -> 다형성이 가능
**자바의 특징 : 재사용
 */
class Parent4{
    Parent4(){
        System.out.println("Parent4");
    }

    Parent4(String str){
        System.out.println("Parent4(String)");
    }
    void m(){
        System.out.println("Parent4.m()");
    }
}
class Child4 extends Parent4{
    Child4(String str){
        System.out.println("Child4");
    }
    void m(){
        System.out.println("Child4.m()");
    }
    void n(){
        System.out.println("Child4.n()");
    }
}
public class PC4Main {
    public static void main(String[] args) {
        Parent4 p4 = new Parent4();
        p4 = new Child4("P4");
        p4.m();
        //Child4 c4 = new Child4("hello");
        Parent4 p = new Child4("hello");
        //자바에서는 생성부의 이름으로 객체가 생성되므로
        //p가 Parent3 타입이더라도 생성부에 있는 자손의 메소드가 호출된다.
        //이 경우 부모의 메소드는 쉐도우 메소드가 되어 호출되지 않는다.
        p.m();
    }
}
/*
자손 클래스의 생성자가 호출될 때 부모 클래스의 생성자가 먼저 호출된다.
디폴트 생성자는 파라미터를 따로 정해주지 않아도 되니까 자동으로 제공할 수 있다.
파라미터가 있는 생성자를 호출하더라도 부모의 디폴트 생성자가 호출된다.
 */
